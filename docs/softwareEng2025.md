---
layout: page
title: "software Eng. lecture note"
permalink: /docs/softwareEng2025
---

# ソフトウェア工学 まとめ（第１回～第６回）
## 第１回
ソフトウェア工学の難しい点は、実務から体系化された知見であるためソフトウェア開発に携わった経験がないとイメージがわかない点や、知見と実践の乖離がある点、個々人のソフトウェア工学の知識だけでは不十分であり、チーム全体で共有する必要がある点などがある。  
 ソフトウェア工学の事例としては、定期的なシステムの更改対応やFOSS4Gの活動やDeep Learningモデルのパラメータ調整などがある。  
 LLMを利用してソフトウェア開発を行う際は、要件定義、バージョン管理、テストが不可欠であり、ソフトウェア工学の知識が求められる。
 ## 第２回
 　ソフトウェアとは、「情報を」扱うプロダクトそのもの、プロダクトを提供する手段である。ソフトウェアは、ハードウェアと異なり劣化はしないが、悪化はする。  
 　ソフトウェアの特徴として、「新しい環境や技術のニーズを満たすよう適応しなければならない」、「新しいビジネス要求を実現するために強化されなければならない」、「より近代的なシステムやデータベースとし相互運用するために拡張されなければならない」、「進化し続ける環境で実行可能となるよう、再構築されなければならない」といったものがある。  
　開発を行う際、問題を解決する方法として、問題を理解する、解決策を計画する、計画を実行に移す、結果が正しいことを理解する、という手順をとることが必要。また、開発を行う際の考え方として、Hookerの７原則といったものなどがある。  
　ソフトウェア工学の定義は、「品質」、「コスト」、「納期」の最適なバランスを実現するための手法・方法論である。  ソフトウェア工学が必要とされる理由として、現在ソフトウェアは社会に欠かせないものになっているため、効率よく品質のいいソフトウェアの開発、メンテナス等を行う必要があること、ソフトウェアの需要に対してIT人材が追いついておらず、効率的に開発・管理することのできる人材が少ないこと、ライフラインとしてのソフトウェアが増加してきているため、不測の事態に対応できる必要があること、ソフトウェアの多様化によるニーズの変化に対応する開発を行う必要があることなどがある。  
　ソフトウェア工学とプログラミングで違う点は、プログラミングはコードなどを作成する作業そのものであるが、ソフトウェア工学はプログラムの想定稼働期間や持続可能性の検討、開発・保守作業のスケールアップなど、時間とスケールなどを意識して行うものという点である。  
　Hyrumの法則は、APIに十分な数のユーザーがいるとき、作成者が約束した仕様でなくても、そのシステムがもつあらゆる挙動に関してそれに依存するユーザーが出てくるという法則であり、ユーザーはソフトウェアの自由な使い方が可能であるということを知っておく必要がある。  
　スケーラブルなソフトウェアを開発する際には、コードベースが持続可能であることや、人件費やコンピュータをはじめとした有限のリソースをスケールするといったことが必要である。開発にかかるコストの種類として、財務コスト、資源コスト、人件コスト、処理コスト、機会コスト、社会コストがある。
## 第３回
　ソフトウェアサイクルとはソフトウェアの誕生から廃止までの過程のことである。具体的な流れとしては、ニーズの発生から要求を具現化するための企画・設計を行い、要件定義書をまとめたあと、実際に開発・保守運用を行い、サービスの終了や新規ソフトウェアへのリニューアルとなどを行うといったものである。  
　要件定義とは、実現する機能・実現しない機能を明確にすることであり、機能の絞り込みやスケジュールの見直しなどにつなげることができる。企業によっては、テンプレート化を行い、もれなく検討できるよう工夫していることもある。要件定義の意義は、プロジェクト関係者とのバイブルとし、スコープ共有などを行うこと、社内外への宣言と協力依頼、外部委託資料やベンダーからのシステム提案を要求することなどである。  
　設計では、要件定義書に基づいて、実際にコーディングができるレベルの仕様書に落とし込む作業を行う。  
　制作では、設計で作成した設計書に従ってシステム構築を行う。この際、内製（自社開発）、外製（外部委託）の方法があり、外部委託を行う際は、納品物の相談やメンテナンスの方法などを考慮する必要などがある。また、オフショア開発という賃金の安い海外企業に外部委託する方法がある。その際には、文化の違いや言語の違いなどに注意して開発を行う必要がある。  
　テスト・デバッグでは、テストを行うことでバグを早期に発見・対処を行うことを理想とする。すべてのテストを行うことは不可能であるため、どの箇所をどの程度テストするかなどの検討が必要となる。  
　運用・保守では、ソフトウェアの維持・管理などをおこなう。この際、稼働後のデータを活用することや、ソフトウェア以外の要因も考慮する必要がある。  
　ソフトウェアに関する情報などを文書化することをドキュメンテーションという。複数人で開発を行う際には、非同期コミュニケーション（文書でのコミュニケーション）が重要となるため、ドキュメンテーションが必要となる。海外企業とのプロジェクトが増える可能性があることやIT技術のほとんどが海外産であることが理由で、文書は英語であることが多い。  
## 第４回
　プロジェクトとは、有期性、独自性を持った仕事のことである。計画する際の考え方として、フォアキャスティング・バックキャスティングがある。フォアキャスティングは、インプット視点の考え方であり、現在の立ち位置から目標に進んでいく。バックキャスティングはアウトプット視点の考え方であり、定めた目標に向けて何が必要かを計画し、達成に向かうもので、プロジェクトに利用される。バックキャスティングでは、目標を明確に設定する必要がある。目標や目標に向けての道筋は、適宜修正可能であることが多い。  
　ソフトウェア分析とは、ソフトウェアを見える化するための手法であり、ソフトウェアの物量、実行性能、開発工数、品質などについて分析を行う。品質（Quality）、コスト（Cost）、納期（Delivery）のことをQCDという。QCDの優先度は、人命に影響があるシステムは品質優先、公共関連システムは費用優先、イベント行事関連システムは納期優先となる。  
　ソフトウェア評価を行う指標として、コードの物量（ステップ数、オブジェクト容量）、ファンクションポイント法、画面の視認性や操作性である使い勝手がある。また、バグ発生率もソフトウェアを行う指標の１つとなる。バグについて考慮する際は、バグを最小化した状態でリリースするか、リリース後に対応するかなどを検討する必要がある。その際、「Hyrumの法則」を想定するべきである。  
　ファンクションポイント法とは、開発の種類と難易度などをもとに定められたファンクションポイントの基準値と、調整値を用いてファンクションポイント値を計算することで評価を行う方法である。FP値 = 基準値 × (0.65 + 調整値 / 100)、原価 = FP値 × 作業単価 × 換算値、で求めることができる。  
　開発プロセスには様々な種類がある。  
　ウォーターフォール型開発プロセスは、上から下へ１方向に開発を進める方法であり、進捗管理が容易で成果物が明確というメリットがあるが、後工程にしわ寄せが集中するリスクがある。  
　スパイラルモデルとは、プログラム開発を小さなフェーズに分割し、フェーズごとにプロトタイプによるデモンストレーションを行いフィードバックをするというものを繰り返すものである。この方法では、プロトタイプの作成時に、想定外の作業量が発生するリスクがある。
　反復型開発プロセスは、ソフトウェアを機能分割し、「反復」という単位で管理するものである。顧客の要求を取り入れやすいことや、部分的に納品が可能となるメリットがあるが、分割のための作業量が増えること、全体像が見えづらいなどのデメリットもある。  
　アジャイルプロセスとは、変化に対応して無駄を廃し、最適な手法で動くソフトウェアの提供を優先する。「できるだけ決定を遅らせる」、「できるだけ早く提供する」を実現するものである。アジャイルのコンセプトには、変化の受容性、速いサイクル・頻繁な納品、シンプルな設計リファクタリング、ペアプログラミングなどがある。アジャイルプロセスを実現する手法としては、スクラム、カンバン、XPなどがある。  
　開発手法は、一長一短であり、どの開発手法を選ぶかは場面・要求による。ハイブリッド型も多い。  
　リスク駆動型開発プロセスとは、想定されるリスクを予め把握するものである。アジャイルでは人的リスク、計画駆動型では技術的課題や規模の拡大・縮小、共通のものとしては、ニーズの変化や政治的・社会的要因などがある。また、予測不能なリスクとして天災や事故・病気、開発環境のクラッシュなどがある。
## ５・６回目
　WBS（Work Breakdown Structure）とは、プロジェクト目標を達成し、必要な要素成果物を生成するために、プロジェクトチームが実行する作業を、要素成果物を主体に階層的に要素分解したものである。  
　プロジェクトを細かな作業に分解した構成図であり、分解した作業を作業順に並べる。WBSを作成するメリットとしては、スコープが明確になること、作業を洗い出すことができること、全体管理と作業計画が明確化される、プロジェクト実行時にWBSに則り実行するだけでよいという点がある。  
　WBSの作成方法は、スコープを明確にし、大きな作業をグルーピングし、グルーピングした作業の相互関連を考え、もれなく各グループの作業を洗い出すという手順で作成する。

## ７回目
### コーディング
　コードは書くよりも読まれることのほうが多く、ソフトウェア開発をするにあたって、読みやすいコードを書くことは必須である。コーディングのルールを定めているものがあり、例としてPEP8などがある。PEP8では次のような要素のルールが定められている。    
* PEP8
    * 1行の長さ
    * インデント
    * スペース
    * 改行
    * import
    * コメント
    * 命名規則  
 
このほかにも要素はある。PEP8はあくまでルールの一つで、他のルールもある。  
このようなコーディングのチェックツールとして、pep8に基づいたflake8や、vscodeのデフォルトのpylintなどがある。  

## ８回目
### バージョン管理
　ファイルを「誰が」、「いつ」、「どのように」変更したかを管理することをバージョン管理という。これらの情報が管理されていれば、多数のメンバーと共同でコード開発を行うことができる。
#### 集中管理型
　リモートリポジトリのみがバージョン管理を行う方法である。この方法は、同時編集をするとコンフリクトが発生しやすい、同期に時間がかかるといった特徴がある。
#### 分散管理型
　リモートリポジトリだけでなく、ローカルリポジトリでも管理を行う方法である。この方法では、リモートリポジトリへのアクセス頻度が低い、障害に頑健などの特徴がある。
### git
　gitは分散管理型のバージョン管理システムである。変更履歴が残る、変更した箇所に戻ることができる、他人と共同編集できるなどの特徴がある。
#### コミット
* ファイル作成・変更・削除の記録である。
* 対象ファイルは一つでも複数でもよい。
* コミットの単位はユーザーが自由に決定できる。

#### レポジトリ
* gitが管理するプロジェクトのフォルダである。
    * ローカルレポジトリ
        *個々のプロジェクト実行環境
    * リモートレポジトリ
        * 共同の管理場所(githubなど

ローカルレポジトリでは、ワークツリーで変更を保存し、コミットしたいファイルを登録し、コミットを行う。コミットは原則変更・削除できない。  
リモートレポジトリでは、ローカルレポジトリでコミットされた変更をリモートリポジトリへ反映(git push)、リモートレポジトリにある内容をローカルレポジトリに反映(git pull)といった操作が行われる。

#### ブランチ
* 作業を枝分かれさせることができ、共同作業、並行作業が可能となる。
* ブランチを管理する方法として、gitフロー/githubフローがある。

## １０回目
### gitコマンド
#### 設定・確認系
* git init
    * gitの初期化・設定開始
* git status
    * ワークツリーのステータスを表示
* git config
    * 設定回りの確認・変更
* git log
    * ログを表示
* git diff
    * ファイルの差分を表示
#### コミット系
* git add
    * ステージングエリアへ追加
* git commit
    * コミットの実行
#### 修正系
* git commit --amend
    * コミットの修正
* git checkout
    * 削除されたファイルの復旧や過去コミットの復元
* git reset
    * コミットのリセット
* git revert
    * コミットの変更を打ち消すコミット
* git rm
    * ファイルとindex情報の削除
#### ブランチ系
* git branch
    * ブランチの作成
* git checkout
    * ブランチの切り替え
* git merge
    * ブランチの統合
* git clone
    * レポジトリをコピー
* git push
    * 変更をアップロード

## １１回目
### github
　リモートレポジトリのホスティングサービスの一つであり、オープンソースソフトウェアの主要なポータルサイトである。
#### clone/fork
* clone
    *  ローカルレポジトリに他ユーザーのレポジトリをコピーすることである。
* fork
    *  自分のリモートレポジトリに他のユーザーのリモートレポジトリをコピーすることである。

## １２回目
### CI/CD
#### Continuous Integration (CI)
* コード変更を共有リポジトリに頻繁に統合するプロセスである。
* 自動テストとビルドを定期的に実行し、バグの早期発見と修正を可能にしている。
* CIの自動化により、開発のスムーズな進行を促進
#### Continuous Delivery (CD)
* コード変更をテスト環境や本番環境に自動的にデプロイするプロセス
* 自動デプロイメントを組み込み、手動操作によりデプロイの必要性を排除
* CDにより、ユーザーフィードバックを迅速に反映可能

#### CI/CDパイプラインの基本的なステップ
1. ソース:ソースコード変更をトリガーにワークフローを起動
2. ビルド:ソースコードをコンパイル
3. テスト:自動テスト
4. デプロイ:テスト済みのコードを本番環境にデプロイ
5. 検証:デプロイされたアプリケーションの動作確認
6. モニタリング:本番環境での継続的な監視

#### GitHub Actions を使用したCI/CD

1. ワークフローの定義:yamlファイルで定義し、.github/workflows/ディレクトリに配置 イベント、ジョブ、ステップで構成
2. トリガー:プッシュ、プルリクエストなどのイベントで起動可能
3. ジョブとステップ: ジョブは並列実行が可能、ステップではシェルコマンドやアクションの使用が可能
4. アクション:再利用可能なワークフローの構成要素
5. ランナー:GitHub提供のホステッドランナーまたはセルフホステッドランナーを使用可能

